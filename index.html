<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Meteor Shower</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    height: 100%;
    width: 100%;
    background: #000;
  }
  canvas { display: block; }
  #startScreen {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(#001a33, #003366);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    font-family: Arial, sans-serif;
  }
  #startScreen h1 {
    font-size: 64px;
    margin-bottom: 40px;
    text-shadow: 2px 2px 5px black;
  }
  #playButton {
    font-size: 28px;
    padding: 15px 40px;
    background: #0099ff;
    color: white;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: 0.3s;
  }
  #playButton:hover { background: #00ccff; }
</style>
</head>
<body>
<div id="startScreen">
  <h1>Meteor Shower</h1>
  <button id="playButton">Play</button>
</div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// Sounds (replace damage URL with hosted Minecraft hurt sound)
const sounds = {
  damage: new Audio("https://quicksounds.com/uploads/tracks/1049772859_1049772859_1049772859.mp3"),
  eat: new Audio("https://actions.google.com/sounds/v1/cartoon/pop.ogg"),
  gameover: new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg"),
  bubble: new Audio("https://actions.google.com/sounds/v1/water/bubble_pop.ogg")
};
for (let key in sounds) sounds[key].volume = 0.5;

// Fish
const fish = { 
  x: canvas.width / 2, y: canvas.height / 2,
  width: 40, height: 20,
  vx: 0, vy: 0,
  health: 100, color: "orange"
};

// Arrays
const meteors = [], foods = [], bubbles = [], weeds = [], stones = [], shields = [];
let score = 0;

// Shield state
let shieldActive = false;
let shieldTimer = 0;
let lastShieldSpawn = Date.now();

// Damage feedback
let damageFlash = 0;
let shakeTime = 0;

// Controls
const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

// Generate weeds and stones
for (let i = 0; i < 15; i++) {
  weeds.push({ x: Math.random() * canvas.width, height: 50 + Math.random() * 100, sway: Math.random() * 0.01 + 0.002, phase: Math.random() * Math.PI * 2 });
}
for (let i = 0; i < 40; i++) {
  stones.push({ x: Math.random() * canvas.width, y: canvas.height - 10 + Math.random() * 10, radius: 5 + Math.random() * 6 });
}

// Update fish
function updateFish() {
  const accel = 0.6, friction = 0.9;
  if (keys["ArrowUp"]) fish.vy -= accel;
  if (keys["ArrowDown"]) fish.vy += accel;
  if (keys["ArrowLeft"]) fish.vx -= accel;
  if (keys["ArrowRight"]) fish.vx += accel;
  fish.vx *= friction; fish.vy *= friction;
  fish.x += fish.vx; fish.y += fish.vy;
  if (fish.x - fish.width < 0) { fish.x = fish.width; fish.vx = 0; }
  if (fish.x + fish.width > canvas.width) { fish.x = canvas.width - fish.width; fish.vx = 0; }
  if (fish.y - fish.height < 0) { fish.y = fish.height; fish.vy = 0; }
  if (fish.y + fish.height > canvas.height) { fish.y = canvas.height - fish.height; fish.vy = 0; }
}

// Draw fish
function drawFish() {
  const angle = Math.atan2(fish.vy, fish.vx);
  ctx.save(); ctx.translate(fish.x, fish.y); ctx.rotate(angle);
  ctx.fillStyle = fish.color;
  ctx.beginPath(); ctx.ellipse(0, 0, fish.width, fish.height, 0, 0, Math.PI * 2); ctx.fill();
  const time = Date.now() * 0.01, tailSwing = Math.sin(time) * 8;
  ctx.beginPath();
  ctx.moveTo(-fish.width, 0);
  ctx.lineTo(-fish.width - 15, -10 + tailSwing);
  ctx.lineTo(-fish.width - 15, 10 + tailSwing);
  ctx.closePath(); ctx.fill();
  const eyeX = fish.width * 0.5, eyeY = -fish.height * 0.4;
  ctx.fillStyle = "white";
  ctx.beginPath(); ctx.arc(eyeX, eyeY, 8, 0, Math.PI * 2); ctx.fill();
  const speed = Math.sqrt(fish.vx * fish.vx + fish.vy * fish.vy);
  ctx.fillStyle = "black";
  ctx.beginPath(); ctx.arc(eyeX + (fish.vx/(speed||1))*3, eyeY + (fish.vy/(speed||1))*3, 4, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
  if (shieldActive) {
    ctx.strokeStyle = "cyan"; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.arc(fish.x, fish.y, fish.width + 15, 0, Math.PI * 2); ctx.stroke();
  }
}

// Meteors
function meteorAttackTrigger() {
  const difficulty = 1 + score / 100;
  if (Math.random() < 0.02 * difficulty) {
    meteors.push({
      x: Math.random() * canvas.width, y: -50,
      vx: (Math.random() - 0.5) * (2 + difficulty * 2),
      vy: 5 + Math.random() * (3 + difficulty * 2),
      radius: 20 + Math.random() * 25
    });
  }
}
function drawMeteors() {
  meteors.forEach((m, i) => {
    m.x += m.vx; m.y += m.vy;
    const gradient = ctx.createRadialGradient(m.x, m.y, m.radius * 0.3, m.x, m.y, m.radius);
    gradient.addColorStop(0, "orange"); gradient.addColorStop(1, "red");
    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = "rgba(255,165,0,0.5)"; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(m.x, m.y); ctx.lineTo(m.x - m.vx * 5, m.y - m.vy * 5); ctx.stroke();
    const dx = fish.x - m.x, dy = fish.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < m.radius + fish.width / 2) {
      if (!shieldActive) {
        fish.health -= 20; damageFlash = 1; shakeTime = 15;
        sounds.damage.cloneNode(true).play();
      }
      meteors.splice(i, 1);
    }
    if (m.y > canvas.height + 50) meteors.splice(i, 1);
  });
}

// Food
function spawnFood() {
  if (Math.random() < 0.004) foods.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: 10 });
}
function drawFood() {
  foods.forEach((f, i) => {
    ctx.fillStyle = "yellow"; ctx.beginPath(); ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2); ctx.fill();
    const dx = fish.x - f.x, dy = fish.y - f.y, dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < f.radius + fish.width / 2) {
      fish.health = Math.min(100, fish.health + 15); score += 10; foods.splice(i, 1);
      sounds.eat.cloneNode(true).play();
    }
  });
}

// Shield
function spawnShield() {
  const now = Date.now();
  if (now - lastShieldSpawn > 60000) {
    shields.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: 15 });
    lastShieldSpawn = now;
  }
}
function drawShields() {
  shields.forEach((s, i) => {
    const gradient = ctx.createRadialGradient(s.x, s.y, 5, s.x, s.y, s.radius);
    gradient.addColorStop(0, "rgba(0,255,255,0.8)");
    gradient.addColorStop(1, "rgba(0,100,255,0.2)");
    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2); ctx.fill();
    const dx = fish.x - s.x, dy = fish.y - s.y, dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < s.radius + fish.width / 2) {
      shieldActive = true; shieldTimer = 300; shields.splice(i, 1);
    }
  });
}

// Bubbles
function spawnBubbles() {
  if (Math.random() < 0.05) bubbles.push({ x: Math.random() * canvas.width, y: canvas.height, radius: 3 + Math.random() * 3, speed: 1 + Math.random() });
}
function drawBubbles() {
  bubbles.forEach((b, i) => {
    b.y -= b.speed; ctx.fillStyle = "rgba(255,255,255,0.6)";
    ctx.beginPath(); ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2); ctx.fill();
    if (b.y < -10) bubbles.splice(i, 1);
  });
}

// Background
function drawWeedsAndStones() {
  weeds.forEach(p => {
    ctx.strokeStyle = "green"; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(p.x, canvas.height);
    ctx.lineTo(p.x + Math.sin(Date.now() * p.sway + p.phase) * 20, canvas.height - p.height); ctx.stroke();
  });
  stones.forEach(s => { ctx.fillStyle = "#444"; ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2); ctx.fill(); });
}

// UI
function drawUI() {
  ctx.fillStyle = "#333"; ctx.fillRect(20, 20, 220, 25);
  ctx.fillStyle = "lime"; ctx.fillRect(20, 20, 2.2 * fish.health, 25);
  ctx.strokeStyle = "black"; ctx.lineWidth = 2; ctx.strokeRect(20, 20, 220, 25);
  ctx.fillStyle = "white"; ctx.font = "16px Arial"; ctx.fillText("Health", 25, 38);
  ctx.font = "22px Arial"; ctx.fillText("Score: " + score, canvas.width - 150, 40);
}

// Main loop
function animate() {
  ctx.save();
  if (shakeTime > 0) { ctx.translate((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20); shakeTime--; }
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, "#001a33"); grad.addColorStop(1, "#003366");
  ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);
  drawWeedsAndStones(); spawnBubbles(); drawBubbles();
  updateFish(); drawFish();
  meteorAttackTrigger(); drawMeteors();
  spawnFood(); drawFood();
  spawnShield(); drawShields();
  drawUI();
  if (damageFlash > 0) { ctx.fillStyle = `rgba(255,0,0,${damageFlash * 0.5})`; ctx.fillRect(0, 0, canvas.width, canvas.height); damageFlash -= 0.05; }
  ctx.restore();
  if (shieldActive) { shieldTimer--; if (shieldTimer <= 0) shieldActive = false; }
  if (fish.health > 0) requestAnimationFrame(animate); else showGameOver();
}

// Game Over
function showGameOver() {
  ctx.fillStyle = "white"; ctx.font = "60px Arial"; ctx.fillText("Game Over", canvas.width/2 - 150, canvas.height/2);
  ctx.font = "30px Arial"; ctx.fillText("Final Score: " + score, canvas.width/2 - 100, canvas.height/2 + 50);
  sounds.gameover.play();
  ctx.fillStyle = "#333"; ctx.fillRect(canvas.width/2 - 70, canvas.height/2 + 100, 140, 50);
  ctx.fillStyle = "white"; ctx.font = "24px Arial"; ctx.fillText("Retry", canvas.width/2 - 30, canvas.height/2 + 133);
  canvas.addEventListener("click", function retryHandler(e) {
    const rect = canvas.getBoundingClientRect(), mx = e.clientX - rect.left, my = e.clientY - rect.top;
    if (mx > canvas.width/2 - 70 && mx < canvas.width/2 + 70 && my > canvas.height/2 + 100 && my < canvas.height/2 + 150) {
      fish.x = canvas.width / 2; fish.y = canvas.height / 2; fish.vx = 0; fish.vy = 0; fish.health = 100; score = 0;
      meteors.length = foods.length = bubbles.length = shields.length = 0;
      damageFlash = shakeTime = 0; shieldActive = false;
      canvas.removeEventListener("click", retryHandler); animate();
    }
  });
}

// Start screen
document.getElementById("playButton").addEventListener("click", () => {
  document.getElementById("startScreen").style.display = "none";
  animate();
});
</script>
</body>
</html>
